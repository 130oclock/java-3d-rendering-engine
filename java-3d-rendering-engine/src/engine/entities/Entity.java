package engine.entities;

import java.awt.Color;
import java.util.ArrayList;
import java.util.List;

import engine.camera.Camera;
import engine.graphics.environment.EnvironmentLight;
import engine.graphics.models.Model;
import engine.graphics.triangle.Triangle;
import engine.matrix.Mat4x4;
import engine.physics.Collider;
import engine.physics.RigidBody;
import engine.quaternion.Quaternion;
import engine.vector.Vector3;

/**
 * The {@code Entity} class represents objects that should be rendered on the screen.
 * All {@code Entity} must have a {@code Model} that it can render. 
 * It stores the position, rotation, scale, and color of an object.
 * It also stores a {@code RigidBody} which is used by the physics engine.
 * <p>
 * Every {@code Entity} is added to the list {@code Entity.entities}.
 * 
 * @author Aidan
 * @since 1.0
 * 
 * @see Model
 * @see RigidBody
 */
public class Entity {
	
	public static List<Entity> entities = new ArrayList<Entity>();
	
	private Model model;
	public Vector3 position;
	private Quaternion rotation;
	private Vector3 scale;
	private Color color;
	
	public RigidBody rig;
	
	/**
	 * Constructs a new Entity given a model, position, rotation, color, and mass.
	 * 
	 * @param model		the 3D model that represents this entity
	 * @param position	the position
	 * @param rotation	the rotation
	 * @param color		the base color
	 * @param mass		the mass
	 * 
	 * @see Model
	 * @see Vector3d
	 * @see Quaternion
	 * @see Color
	 */
	public Entity(Model model, Vector3 position, Quaternion rotation, Color color, double mass) {
		this.model = model;
		this.color = color;
		
		this.rig = new RigidBody(position, rotation, mass, calcBoundingBox());
		this.position = this.rig.getPos();
		this.rotation = this.rig.getRot();
		this.scale = new Vector3(1, 1, 1);
		
		entities.add(this);
	}
	
	public Entity(Model model, double mass) {
		this(model, new Vector3(), new Quaternion(), Color.WHITE, mass);
	}
	
	public Entity(Model model, double x, double y, double z, double mass) {
		this(model, new Vector3(x, y, z), new Quaternion(), Color.WHITE, mass);
	}
	
	public Entity(Model model, double x, double y, double z, Quaternion rotation, double mass) {
		this(model, new Vector3(x, y, z), rotation, Color.WHITE, mass);
	}
	
	public Entity(Model model, double x, double y, double z, double mass, Color color) {
		this(model, new Vector3(x, y, z), new Quaternion(), color, mass);
	}
	
	public Entity(Model model, Vector3 position, double mass) {
		this(model, position, new Quaternion(), Color.WHITE, mass);
	}
	
	/**
	 * Projects all triangles from this entity's model onto screen space.
	 * 
	 * @param camera	the main camera of the scene
	 * @param matView	the view matrix generated by the engine
	 * @param matProj	the projection matrix generated by the engine
	 * @param WIDTH		the width of the screen
	 * @param HEIGHT	the height of the screen
	 * @param light		the environmental light of the scene
	 * 
	 * @see Camera
	 * @see Mat4x4
	 * @see EnvironmentLight
	 * @see Triangle
	 */
	public void project(Camera camera, Mat4x4 matView, Mat4x4 matProj, int WIDTH, int HEIGHT, EnvironmentLight light) {
		Triangle.projectTriangles(this.model.mesh, this.position, this.rotation, this.scale, camera, matView, matProj, WIDTH, HEIGHT, light, this.color);
	}
	
	/**
	 * Calculates a bounding box for this entity based on the minimum and maximum vertices of the model.
	 * 
	 * @return a {@code Collider} object that fits around the entire model
	 */
	public Collider calcBoundingBox() {
		Vector3 max = new Vector3(Double.MIN_VALUE, Double.MIN_VALUE, Double.MIN_VALUE);
		Vector3 min = new Vector3(Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE);
		for (Triangle tri : model.mesh) {
			Vector3[] p = tri.p;
			Triangle.calcTriangleMax(p, max);
			Triangle.calcTriangleMin(p, min);
		}
		return new Collider(max, min);
	}
}
